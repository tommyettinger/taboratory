# taboratory
Generate classes from TSV tables; reload on demand!

# Use

Download the Windows .exe (easy to use, if you are on Windows) or the .jar (harder to use, but works on all platforms).
For the .exe, you can drag and drop any appropriately-formatted .tsv file onto taboratory.exe and get files placed in
`/generated/` next to taboratory.exe . For the .jar, make sure you have a recent JVM (21 is recommended, but as low as
8 should work), and run from the command line `java -jar taboratory.jar MyTabSeparatedValues.tsv`, replacing with
whatever your appropriately-formatted .tsv file is named.

# Format

The first part of the input file is, as in most TSV files, a header line. It contains the column names and types, with
one cell per column. This means both name and type are in the same cell; they are separated by a colon, `:`. If a caret,
`^`, is present at the end of a cell immediately after the type (or after the name if no colon is present), it marks
that column as the key if it has the String type (the default). The key should be unique in each file, and will be used
to look up entries in the `Map` this can load at runtime. 

Supported "basic" types are:
- `String`, referring to `java.lang.String`
    - This is the default if no type at all is specified for a column, when no colon is present.
    - It can also be written with the aliases `str` and `s`.
    - Only this type can be used as a key to the generated `Map`; typically the first column is a String for the key.
- `boolean`, the primitive true-or-false type; this will be boxed if used in a map.
    - It can also be written with the aliases `bool` and `b`.
    - The values can also be written as `t` or `f`; this doesn't need the full `true` or `false` to be written out.
- `char`, the primitive character type; this will be boxed if used in a map.
    - It can also be written with the alias `c`.
- `int`, the primitive 32-bit integer type; this will not be boxed in maps.
    - It can also be written with the alias `i`.
    - This may be used as a key in a map.
- `long`, the primitive 64-bit integer type; this will not be boxed in maps.
    - It can also be written with the alias `l`; be careful that this isn't mistaken for another symbol, like `1`.
    - This may be used as a key in a map.
- `float`, the primitive 32-bit floating-point type; this will not be boxed as a value in a map.
    - It can also be written with the alias `f`.
- `double`, the primitive 64-bit floating-point type; this will be boxed if used in a map.
    - It can also be written with the alias `d`.
- `Junction`, a class in jdkgdxds that acts as an easy-to-read predicate for Collections of String.
    - This may be used as a key in a map.
    - It can also be written with the alias `j`.
- Any class generated by taboratory in the same package, as long as the other class has a key column.
    - The type here should be just the class section of the top line, such as `Job`, not `generated.Job`.

In addition to this, there are some "group" types with multiple values in one cell, with the boundary between values
specified in the name of the type. The boundary is meant to be adapted to fit whatever data you have, so if you have
String values separated by a comma and a space in a list inside a cell, you could use `, ` as the separator in a list
type. This would look like `String[, ]` as the type. You could also use String as the type if you want to parse it
yourself, or if you have some especially complicated case in each cell. Supported "group" types are:

- Lists containing items of a basic type (one type per list).
    - These are written with the basic type's name or alias, followed immediately by square brackets with the boundary
      inside those brackets.
    - This looks like `String[ ]` for space-separated Strings, or `i[;;]` for ints separated by two semicolons.
    - When you write a list value, you separate each basic item in it with the boundary. In the first example given,
      with the type `String[ ]`, this would look like `Bill Bob Carl Joe` to produce a 4-element list of Strings.
- Maps containing keys of a basic type and values of a possibly-different basic type (one key type, one value type).
    - These are written with the key type's name or alias, followed immediately by curly braces with the boundary inside
      those braces, and immediately after that the value type's name or alias.
    - This looks like `String{, }double` for maps with String keys and Double values (the doubles become boxed in maps)
      separated by comma and space, or `i{ }s` for maps with primitive int keys and String values separated by space.
    - When you write a map value, you separate each key and each value in it with the boundary. In the first example
      given, with the type `String{, }double`, this would look like `Bill, 2.3, Bob, 4.2, Carl, 3.14, Joe, 9999` to
      produce a map with 4 key-value pairs.
    - You can use int or long keys, and they won't be boxed. Similarly, you can
      use int, long, or float values without boxing. The syntax is the same. Keys can be String, Junction, or any boxed
      type if an Object key must be used.
    - Maps maintain insertion order using Ordered Maps from jdkgdxds.
- Maps containing keys of a basic type and values that are each lists of a basic type (one type for the keys and one
  list type for the values).
    - This looks like `String{,}int[/]` for a case where keys are `String`s and values are lists of `int`.
    - A sample that uses this would be `"Jim,1/2/4,Pam,5/1/1,Dwight,0/0/-1"`

An example header line looks like:

```
name	description	offense:int	defense:int	talents:Talent[;;]	skills:str{,}int
```

Here, name and description are String type because no type is specified, offense and defense are int type, talents is a
list of Talent values (where Talent is expected to be made by taboratory at some point before this class is compiled)
separated by two semicolons, and skills is a map of String keys to int values, separated by commas. Since the top
line specified name as the key column, this `Job` class could be used from other taboratory data, where a row would be
referenced by a (unique) value in the name column here.

After the header line, it's just filling as many rows as you need with data that matches the types in the header.
With the header above, a row of that data could look like:

```
Ninja	A nimble assassin	9	1	Poison;;Martial Arts	Vanish,2,Smoke Bomb,1,Shadow Dagger,2
```

This makes the name (and so the key) `Ninja`, the description `A nimble assassin`, the offense value `9`, the defense
value `1`, the Talents list reference two talents called `Poison` and `Martial Arts`, and the skills map consisting
of `Vanish` mapped to `2`, `Smoke Bomb` mapped to `1`, and `Shadow Dagger` mapped to `2`. The Talent objects will be
looked up in a class in the same package (by default, `generated`), calling `Talent.get("Poison")` to get the
first Talent instance and `Talent.get("Martial Arts")` to get the other. If you have your own non-taboratory class that
you want to use like Talent is used here, you just need it to have a static method `get()` that takes a String and
returns an appropriate instance of that class.

# Notes

Build a Graal Native Image exe by finding the GraalVM 24 bin folder and using its native-image:

`native-image.cmd -march=compatibility -cp picocli-4.7.7.jar -jar taboratory.jar`

For my machine, where I have Graal 24 installed by IDEA, it looks like this:

`%homedrive%%homepath%\.jdks\graalvm-jdk-24.36.1\bin\native-image.cmd -march=compatibility -cp picocli-4.7.7.jar -jar headless\build\libs\taboratory.jar`